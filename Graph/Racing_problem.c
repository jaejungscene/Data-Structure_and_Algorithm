/**
 * N 개의 도시가 있고 N-1 개의 고속도로가 각 도시들을 연결하고 있다고 가정하자.
 * 각 고속도로는 양방향이며 서로 다른 두 개의 도시를 연결한다. 그리고 임의의 두 도시는 단 하나의 경로에 의해 연결된다.
 * 즉,같은 도시를 두 번 이상 방문하지 않고 한 도시에서 출발하여 다른 도시에 도착하는 방법은 유일하다.
 * 각 고속도로의 길이는 킬로미터 단위로 나타내며 정수 값이다.
 * 경주코스는 출발 도시와 도착 도시가 서로 달라야 하며 길이는 정확하게 K 킬로미터인 경로이다.
 * 그리고 충돌을 방지하기 위해 한 고속도로를 두 번 이상 사용하지 않는다.
 * 또한 교통체증을 줄이기 위해 되도록 최소 갯수의 고속도로를 사용하여 경주코스를 구성하려고 한다.
 * N – 도시의 수(최대 20개). 각 도시의 index는 0 번부터 19 번까지 정수로 나타낸다. K – 경주코스의 길이.
 * 입력: 첫째 줄에 N과 K가 주어진다. 둘째 줄부터 N-1번째 줄 까지는 각각 “도시(출발) 도시(도착) 고속도로 길이”를 입력한다.
 * ● N (𝟏 ≤ 𝑵 ≤ 𝟐𝟎)
 * ● K (𝟏 ≤ 𝑲 ≤ 𝟗𝟗)
 * 출력: 길이가 K 인 경주코스를 구성하는데 필요한 최소 고속도로의 개수를 출력한다. 만약 길이가 K 인 경주코스가 없다면 ‘INVALID’를 반환한다.
*/

#include <stdio.h>
#define TRUE 1
#define FALSE 0

/******* hyper parameter *******/
#define N 3
#define K 1
int graph[N][N] = { {0,1,0},
  {1,0,1},
  {0,1,0} };
/*********************************/

int visited[N] = {0};
int min = 1000;

int num = 0;
int sum = 0;

void fresh(){
  num = 0;
  sum = 0;
  for(int i=0; i<N; i++)
    visited[i] = 0;
}

void find(int i)
{
  int tmp_sum, tmp_num;
  visited[i] = TRUE;
  for(int j=0; j<N; j++)
  {
    if(graph[i][j]!=0 && visited[j]==FALSE)
    {
      sum = sum + graph[i][j];
      num++;
      if(sum < K){
        tmp_sum = sum;
        tmp_num = num;
        find(j);
        visited[j] = FALSE;
        sum = tmp_sum;
        num = tmp_num;
        sum = sum - graph[i][j];
        num--;
      }
      else if(sum == K){
        if(min > num){
          min = num;
        }
        return; // 계속 그래프를 보면 어차피 지금의 최소 고속도로 개수와 같거나 많은 상황들이므로 굳이 그래프를 더 보지 않는다.
      }
      else{// (sum > K) 상황에선 i번째 노드와 연결된 고속도로 중 더 작은 길이를 가진 고속도로가 있는지 그래프를 더 살펴본다.
        sum = sum - graph[i][j];
        num--;
      }
    }
  }
  return;
}

int main(){
  for(int i=0; i<N; i++){
    find(i);
    fresh();
  }
  
  if(min == 1000)
    printf("invalid\n");
  else
    printf("%d\n", min);
  return 0;
}

/*

{ {0,3,4,0,0,0,3,0,0,0,0},
  {3,0,0,0,0,0,0,0,0,0,0},
  {4,0,0,5,0,0,0,0,0,0,0},
  {0,0,5,0,4,0,0,0,0,0,0},
  {0,0,0,4,0,6,0,0,0,0,0},
  {0,0,0,0,6,0,0,0,0,0,0},
  {3,0,0,0,0,0,0,2,5,0,0},
  {0,0,0,0,0,0,2,0,0,0,0},
  {0,0,0,0,0,0,5,0,0,6,7},
  {0,0,0,0,0,0,0,0,6,0,0},
  {0,0,0,0,0,0,0,0,7,0,0} }

{ {0,1,0},
  {1,0,1},
  {0,1,0} }

{ {0,1,0,0},
                    {1,0,2,4},
                    {0,2,0,0},
                    {0,4,0,0} }

{ {0,1,0,0},
                    {1,0,4,2},
                    {0,4,0,0},
                    {0,2,0,0} }



*/